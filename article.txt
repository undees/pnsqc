Document Your Software Project
==============================
Ian Dees <ian.s.dees@tektronix.com>
v0.1, June 2010:
First draft.

``Welcome to the team. Here are a couple of bugs you can fix to learn
your way around the source code. You'll probably want to start by
looking in this subsystem.''

Have you heard this before? Perhaps it was followed by a wild goose
chase through the code, as you strove to read the mind of the coder
who came before you.

Or perhaps it turned out differently. You may have opened the project
folder to find a welcome mat of sorts. Someone may have carefully laid
out a +README+ file giving a quick overview of the directory structure,
names of functions to look at first, and even code samples hinting at
how to use or extend the code. Maybe that someone was you, several
years ago.

In this article, we're going to discuss how programming documentation
goes wrong, and what you can do about it. It doesn't take a
world-class technical writer to document a software project (and it
certainly didn't take one to produce this paper!). It just takes a few
times being baffled by an unfamiliar, undocumented code base.

What Do You Mean, ``Documentation?''
------------------------------------

Any kind of technical documentation can benefit from care and
attention to detail. In-code commentary, user manuals, architectural
walkthroughs, and requirements documents should all be written in
clear language and kept up to date. On any given project, each of
these types is going to come with its own set of constraints on
length, level of formality, and assumptions about its audience.

This article focuses on one kind of writing: software library
documentation. Your audience will be your fellow programmers, very
likely including yourself. The scope is something quite a bit narrower
than an entire system--something along the lines of one library or
subsystem.

Thought Experiment
~~~~~~~~~~~~~~~~~~

Think back to the last time you visited an unfamiliar subdirectory of
your source tree for the first time. Perhaps you were assigned to help
another teammate develop a feature, or simply found an interesting
name in the project directory and wondered, ``What's in here?''

How easy was it to learn the purpose of that particular subsystem? Was
there a +README+, or was it cultural knowledge among the team what that
directory was for? Was there any documentation at all in the directory,
or were you expected to look in some central location for everything?

If you did find documentation, how helpful was it? Was it boring or
engaging? Did it give a quick overview of the more important files in
the directory? Was there a ``Hello world'' code example you could try
out? If so, was the example up to date?

Keep your answers to these questions in mind as you read the next
couple of sections.

Document Misfits
----------------

People write documents for good reasons. (And not just ``because
management said to.'') You can probably think of several right off
the bat: pride in one's work, sympathy for one's co-workers, or even
simple self-preservation.

What goes wrong, then? Assuming authors' hearts are in the right
place, we can imagine that a document that fails us may just be the
wrong kind of document for the task. Let's look at a few ways in which
a software library might not be getting the textual attention it
deserves..

Invisible Ink
~~~~~~~~~~~~~

A subsystem might have no documentation at all. This scenario is
distressingly common, and to my embarrassment I've been party to it as
well. I'm going to take advantage of the bully pulpit afforded to
paper authors, and speculate on some of the causes.

We skip documentation because we run out of time. We skip it because
we're self-conscious about writing narrative text. We start a tiny new
project and think, ``This thing's way too small to bother documenting;
just look at the source code!'' We get frustrated with flaky writing
tools and bureaucratic workflows.

As we'll soon see, there are a few simple things you can do to address
nearly all of these causes of missing documentation.

Ghost Writer
~~~~~~~~~~~~

A close cousin of the invisible document is the ghost-written
document; that is, the automated help pages generated from the
comments in your source code. These are fine for giving your readers a
way to look up what your library's +foo()+ function does. But how are
they supposed to know that's the function they need? Machines can't do
the job we're talking about today: the job of making a newcomer feel
welcome to a project.

One Document to Rule Them All
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some shops demand that one file or directory be the gateway to all
understanding of the project. Hardware layouts, software architecture,
UML diagrams, elaborate class hierarchies, and everything else gets
dumped into this one location.

It's easy to see why this approach is so common. If every fact about
the system lives in one place, then one can turn to the master
document for any answer--in theory. The problem is that these would-be
museums quickly become mausoleums. Those elaborate diagrams that got
produced not out of any real need, but because someone thought the
team should have them? Dumped in the burial ground and
forgotten. Which leads us to our final misfit.

Ancient Scrolls
~~~~~~~~~~~~~~~

Documents need to be kept up to date. It feels silly even having to
say this. But I've definitely encountered libraries whose example code
no longer ran unaltered, or whose descriptions didn't match the API
any more. I'll bet you have, too.

People don't come into the office and decide to put off documentation
updates. Maintaining the docs just doesn't become part of our habits,
for the same reason that creating them doesn't become part of our
habits. Every little barrier in the way of writing looks like an
impenetrable wall when we think about doing it over and over again in
maintenance mode.

It follows that any little thing we can do to stop ourselves from
dreading writing and just _write_ will have a big payoff. I'd like to
discuss several such things you can do in service of this goal. To tie
these various activities together, I'd like to propose a metaphor for
software documentation that carries warm, familiar connotations for
most of us.

The Magazine Metaphor
---------------------

When you were cutting your teeth as a coder, did you ever subscribe to
_Dr. Dobb's Journal_? How about _BYTE_, or _COMPUTE!_? Remember the
thrill of diving into some brand new technique, and being presented
with real, live code samples that you could actually type in and run
right on the spot?

It may be a bit unrealistic to expect users of our libraries to feel
quite that level of excitement about software that's just part of our
day jobs. Even so, a well-written project introduction has a few
things in common with a short programming article in a magazine. Let's
look into a few of these features.

One Sitting
~~~~~~~~~~~

The engineer trying out your library doesn't have all day to read an
entire binder's worth of writing. There's a place for exhaustive
coverage of a subsystem: the reference material. Give your reader a
few pages that can be printed out and read over a cup of coffee.

Working Examples
~~~~~~~~~~~~~~~~

One of the most heavily leaned-on subsystems in our office has a
well-loved usage guide. It's not easy to find in our directory
structure (``was that in +documents/misc/toolname+, or
+documents/manuals+?''). And it's not quite up to date with the latest
version of the code it describes. But it's worth seeking out and
reading anyway, because it does such a thorough job explaining how to
write code for this subsystem.

In one sixty-line example that fits on a single page, the author is
able to demonstrate all the library's major features. In the adjoining
text, he explains what each single line of code does.

Curated Code Excerpts
~~~~~~~~~~~~~~~~~~~~~

The most enjoyable articles show more than just one ``Hello world''
example. They compare and contrast what code might look like before
and after applying the technique they're describing. They peel back
the API and show some facet of the underlying implementation.

I sometimes struggle with how much code to show in an introductory
document. Too little, and the reader won't know where to turn after
getting the first example working. Too much, and the whole thing
degenerates into a parade of excerpts that don't have enough context
to be meaningful. This is where the ``magazine article'' theme comes
in most helpful to me. Articles show off a small series of curated
code examples that capture the essence of a library.

A Real Page-Turner
~~~~~~~~~~~~~~~~~~

With all this talk of keeping things short, you're probably wondering
how to fit in everything the reader might need to know about the
software. It's important to provide good coverage, but an introduction
is not the place for that. The introduction absolutely _is_ the place,
however, for telling your reader where to get more information: a
series of in-depth guides, full API documentation, a network of wiki
pages, and so on.

How To Get There From Here
--------------------------

There's no need to go overboard with the magazine metaphor. You don't
need fancy formatting, callouts, author bios, personality quizzes, or
intrusive ads. Simply use the idea insofar as it helps you get the job
done, and discard it as soon as it loses its usefulness.

Assuming you do find a few parts of the idea useful, how can you
incorporate them into your workflow?

Keep It With the Code
~~~~~~~~~~~~~~~~~~~~~

The further you have to reach from your source tree to maintain your
documents, the less often you're going to maintain them. It's fine to
have a central place for the big stuff: giant architecture diagrams
(on second thought, maybe you could just do without those),
requirements documents, histories of design decisions, and so on. But
your readers need _something_ right next to the source code to get
started--and so do you.

You may be thinking, ``But we don't want to clutter up the source
tree! There's no conceptual room for a giant +README+.''
Precisely. Keeping this material right next to the source should
provide an upper bound on its size and complexity.

Use Tools That Fit Your Hand
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We're all under schedule pressure. How do we make sure that the task
of creating and maintaining the documentation isn't the first thing
thrown out the window as the deadline draws near? Choosing a
lightweight format is one way we can trick ourselves into doing the
right thing. If we think of our project guide as a magazine article,
it seems less difficult and more approachable.

Choosing a writing tool is another part of this psychological
game. Use the tool that's not going to become an excuse for you to
skip out on your writing duties. If you find yourself thinking, ``Now
I have to wait all day for the word processor to launch,'' you may
prefer a plain-text format and the comfort of your favorite
programming editor. If the prospect of memorizing obscure bold /
italic codes annoys you, a dedicated writing tool may be the best fit.

Plain Text and Its Relatives
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Don't underestimate the power of plain text. It can be read from the
command line with no additional tools, sent around as e-mail, and
tracked usefully with revision control tools. This includes the
``humane markup'' languages, such as Textile, Markdown,
ReStructuredText, and AsciiDoc. Using one of these formats means just
writing like you'd normally do, and then adopting a few simple
conventions for section titles, code excerpts, and so on. For example,
here's how a README file might begin in ReStructuredText:

--------------------------------------------------------------------
include::example.rst[]
--------------------------------------------------------------------

The other text formats look similar to this. I chose ReStructuredText
for this example because it's the one used by Sphinx, the tool behind
the Python library documentation. Sphinx is designed for writing books
and articles, so it's very close to the sweet spot for introducing
readers to a software library. If you happen to be writing about a
Python project, Sphinx can link to your generated source
documentation.

Machine-friendly Markup
^^^^^^^^^^^^^^^^^^^^^^^

Formats such as DocBook, LaTeX, HTML, and RTF are also text-based, but
typically involve inserting instructions for the typesetting among the
words of your document. To one degree or another, they're more
difficult to write by hand than plain text (LaTeX is the easiest in
this regard). This added complexity pays off, though, when it's time
to ask a machine to do something to your text--such as print it,
translate it into another format, or automatically update snippets of
your source code.

Incidentally, the AsciiDoc format described earlier generates DocBook
XML behind the scenes. So you can get the best of both worlds: the
ease of plain text, and the feature set of the entire DocBook
toolchain.

Word Processors
^^^^^^^^^^^^^^^

The tools we've talked about so far have been pretty
programmer-oriented. Some people prefer a change of scene when they're
working on documentation. They'd rather see formatting changes while
they're interacting with a document, rather than having to wait for a
conversion to PDF.

One thing to watch out for if you go this route is that you're going
to have to work a little harder to keep your code examples up to
date. We'll talk about that a little more in a moment.

Which One?
^^^^^^^^^^

As I said before, it comes down to choosing the tool that stays out of
your way. For instance, the software team lead and I were creating a
design document together for a new feature. We started by writing
bulleted lists in our text editors. We considered porting the text to
a ``real'' tool, such as a word processor, later on. At the moment,
though, we didn't want anything to disrupt the flow of ideas. So we
continued working in text, gradually expanding each bullet into
sections, titles, and paragraphs.

As it turns out, we ended up with something so close to the ``humane
markup'' formats that it was the work of a few minutes to clean it up
and generate a nice-looking PDF to share with the rest of the team.

Keep the Code Up to Date
~~~~~~~~~~~~~~~~~~~~~~~~

Having stale code examples that break for your first-time users is a
recipe for frustration. If your library implements a fairly stable
API, especially one that's defined in a standard somewhere, you may
not have to worry about this much--just go ahead and paste your source
examples into your document.

But if your project's programming interface changes frequently, you'll
need to re-run your examples and keep the versions inside your
document up to date. This task is easier with the text-based
formats; most have commands that say in effect, ``insert the source
code from this external file here.'' For the ones that lack this
feature, you can use a templating engine such as the Ruby-based eRubis
or the language-independent m4.

Automatic updates are a little trickier when you're using a word
processor. If you're only responsible for documenting a couple of
projects, you might just add a recurring task in your calendar to try
the snippets manually and make any needed fixes. Any more than that,
though, and the manual approach will get old quickly. You can use your
word processor's linking feature and store your snippets in external
files (which are easier to test automatically).

You can also just update the document by writing a program. Most word
processors have either a scripting API or an XML-based file format
that's easy to generate automatically.

Provide a Path from ``Hello world'' to Mastery
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

An engineer who stumbles across your project directory has a number of
questions, which almost certainly include the following:

* What is this thing?
* How do I get it and all the dependencies installed?
* What's the equivalent of ``Hello world'' for this system?

As Jacob Kaplan-Moss writes in his excellent blog post on project
documentation, ``Be easy.... But not too easy.'' You want your reader
to get an early success, then challenge him with a couple more
realistic examples, then point him toward the more in-depth resources
that live elsewhere.

Closing Thoughts
----------------

If you're the maintainer of a small- to mid-sized software project,
the programmers using your software deserve great documentation to
help get them started. One day, one of those programmers may be you!
For your sake and theirs, treat yourself to good documentation.

It's easy for writing to get lost in competition with other, more
urgent, activities: testing, coding, debugging, planning, and so
on. You've got to get rid of any excuse not to write. That means
choosing whichever tool is going to stay out of your way. It means
setting realistic expectations of what you're trying to accomplish.

If it helps, by all means choose a mental picture to rally behind. You
may find inspiration in the old computing magazine articles that once
inspired you to try out someone else's code.
