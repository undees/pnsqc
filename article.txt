Document Your Software Project
==============================
Ian Dees <ian.s.dees@tektronix.com>
v0.1, June 2010:
First draft.

``Welcome to the team. Here are a couple of bugs you can fix to learn
your way around the source code. You'll probably want to start by
looking in this subsystem.''

Have you heard this before? Perhaps it was followed by a wild goose
chase through the code, as you strove to read the mind of the coder
who came before you.

Or perhaps it turned out differently. You may have opened the project
folder to find a welcome mat of sorts. Someone may have carefully laid
out a +README+ file giving a quick overview of the directory structure,
names of functions to look at first, and even code samples hinting at
how to use or extend the code. Maybe that someone was you, several
years ago.

In this article, we're going to discuss how programming documentation
goes wrong, and what you can do about it.

What Do You Mean, ``Documentation?''
------------------------------------

Any kind of technical documentation can benefit from care and
attention to detail. In-code commentary, user manuals, architectural
walkthroughs, and requirements documents should all be written in
clear language and kept up to date. On any given project, each of
these types is going to come with its own set of constraints on
length, level of formality, and assumptions about its audience.

This article focuses on one kind of writing: software library
documentation. Your audience will be your fellow programmers, very
likely including yourself. The scope is something quite a bit narrower
than an entire system--something along the lines of one library or
subsystem.

Thought Experiment
~~~~~~~~~~~~~~~~~~

Think back to the last time you visited an unfamiliar subdirectory of
your source tree for the first time. Perhaps you were assigned to help
another team develop their feature, or simply found an interesting
name in the project directory and wondered, ``What's in here?''

How easy was it to learn the purpose of that particular subsystem? Was
there a +README+, or was it cultural knowledge among the team what that
directory was for? Was there any documentation at all in the directory,
or were you expected to look in some central location for everything?

If you did find documentation, how helpful was it? Was it boring or
engaging? Did it give a quick overview of the more important files in
the directory? Was there a ``Hello world'' code example you could try
out? If so, was the example up to date?

Keep your answers to these questions in mind as you read the next
couple of sections.

Document Misfits
----------------

People write documents for good reasons. (And not just ``because
management said to.'') You can probably think of several right off
the bat: pride in one's work, sympathy for one's co-workers, or even
simple self-preservation.

What goes wrong, then? Assuming authors' hearts are in the right
place, we can imagine that a document that fails us may just be the
wrong kind of document for the task. Let's look at a few ways in which
a software library might not be getting the textual attention it
deserves..

Invisible Ink
~~~~~~~~~~~~~

A subsystem might have no documentation at all. This scenario is
distressingly common, and to my embarrassment I've been party to it as
well. I'm going to take advantage of the bully pulpit afforded to
paper authors, and speculate on some of the causes.

We skip documentation because we run out of time. We skip it because
we're self-conscious about writing narrative text. We start a tiny new
project and think, ``This thing's way to small to bother documenting;
just look at the source code!'' We get frustrated with flaky writing
tools and bureaucratic workflows.

As we'll soon see, there are a few simple things you can do to address
nearly all of these causes of missing documentation.

Ghost Writer
~~~~~~~~~~~~

A close cousin of the invisible document is the ghost-written
document; that is, the automated help pages generated from the
comments in your source code. These are fine for giving your readers a
way to look up what your library's +foo()+ function does. But how are
they supposed to know that's the function they need? Machines can't do
the job we're talking about today: the job of making a newcomer feel
welcome to a project.

One Document to Rule Them All
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some shops demand that one file be the gateway to all understanding of
the project. Hardware layouts, software architecture, UML diagrams,
elaborate class hierarchies, and everything else gets dumped into this
one location.

It's easy to see why this approach is tempting. If every fact about
the system lives in one place, then one can turn to the master
document for any answer--in theory. The problem is that these would-be
museums quickly become mausoleums. Those elaborate diagrams that got
produced not out of any real need, but because someone thought the
team should have them? Dumped in the burial ground and
forgotten. Which leads us to our final misfit.

The Ancient Scrolls
~~~~~~~~~~~~~~~~~~~

Documents need to be kept up to date. It feels silly even having to
say this. But I've definitely encountered libraries whose example code
no longer ran unaltered, or whose descriptions didn't match the API
any more. I'll bet you have, too.

People don't come into the office and decide to put off documentation
updates. Maintaining the docs just doesn't become part of our habits,
for the same reason that creating them doesn't become part of our
habits. Every little barrier in the way of writing looks like an
impenetrable wall when we think about doing it over and over again in
maintenance mode.

It follows that any little thing we can do to stop ourselves from
dreading writing and just _write_ will have a big payoff. I'd like to
discuss several such things you can do in service of this goal. To tie
these various activities together, I'd like to propose a metaphor for
software documentation that carries warm, familiar connotations for
most of us.

The Magazine Metaphor
---------------------

When you were cutting your teeth as a coder, did you ever subscribe to
_Dr. Dobb's Journal_? How about _BYTE_, or _COMPUTE!_? Remember the
thrill of diving into some brand new technique, and being presented
with real, live code samples that you could actually type in and run
right on the spot?

It may be a bit unrealistic to expect users of our libraries to feel
quite that level of excitement about software that's just part of our
day jobs. Even so, a well-written project introduction has a few
things in common with a short programming article in a magazine. Let's
look into a few of these features.

One Sitting
~~~~~~~~~~~

The engineer trying out your library doesn't have all day to read an
entire binder's worth of writing. There's a place for exhaustive
coverage of a subsystem: the reference material. Give your reader a
few pages that can be printed out and read over a cup of coffee.

Working Examples
~~~~~~~~~~~~~~~~

One of the most heavily leaned-on subsystems at work has a well-loved
usage guide. It's not easy to find in our directory structure (``was
that in +documents/misc/toolname+, or +documents/manuals+?''). And
it's not quite up to date with the latest version of the code it
describes. But it's worth seeking out and reading anyway, because it
does such a thorough job explaining how to write code for this
subsystem.

In one sixty-line example that fits on a single page, the author is
able to demonstrate all the library's major features. In the adjoining
text, he explains what each single line of code does.


 from work had a how-to guide that was
hard to find and not quite up to date with the latest code, but that
was worth the effort to find and read. The author had carefully laid
out 

Curated Code Excerpts
~~~~~~~~~~~~~~~~~~~~~

TBD

A Real Page-Turner
~~~~~~~~~~~~~~~~~~

TBD

How To Get There From Here
--------------------------

TBD

Keep It With the Code
~~~~~~~~~~~~~~~~~~~~~

TBD

Use Tools That Fit Your Hand
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We're all under schedule pressure. How do we make sure that the task
of creating and maintaining the documentation isn't the first thing
thrown out the window as the deadline draws near? Choosing a
lightweight format is one way we can trick ourselves into doing the
right thing. If we think of our project guide as a magazine article,
it seems less difficult and more approachable.

Choosing a writing tool is another part of this psychological
game. Use the tool that's not going to become an excuse for you to
skip out on your writing duties. If you find yourself thinking, ``Now
I have to wait all day for the word processor to launch,'' you may
prefer a plain-text format and the comfort of your favorite
programming editor. If the prospect of memorizing obscure bold /
italic codes annoys you, a dedicated writing tool may be the best fit.

Plain Text and Its Relatives
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Don't underestimate the power of plain text. It can be read from the
command line with no additional tools, sent around as e-mail, and
tracked usefully with revision control tools. This includes the
``humane markup'' languages, such as Textile, Markdown,
ReStructuredText, and AsciiDoc. Using of these formats means just
writing like you'd normally do, and then adopting a few simple
conventions for section titles, code excerpts, and so on. For example,
here's how a README file might begin in ReStructuredText:

  Halt-o-Meter
  ============
  Welcome to the Halt-o-Meter! This software reads the source code of
  your program and tells you whether or not it will run to
  completion (and they said it was impossible!).

  Example
  -------
  Save the following code in ``example.c``::
    int main() {
      for (;;);
      return 0;
    }

  Now, run Halt-o-Meter::
    C:\> haltometer example.c
    Checking... example.c does NOT halt.

Machine-friendly Markup
^^^^^^^^^^^^^^^^^^^^^^^

Formats such as DocBook, LaTeX, and RTF are also text-based, but
typically involve inserting instructions for the typesetting among the
words of your document. To one degree or another, they're more
difficult to write by hand than plain text (LaTeX is the easiest in
this regard). This added complexity pays off, though, when it's time
to ask a machine to do something to your text--such as print it,
translate it into another format, or automatically update snippets of
your source code.

Incidentally, the AsciiDoc format described earlier generates DocBook
XML behind the scenes. So you can get the best of both worlds: the
ease of plain text, and the feature set of the entire DocBook
toolchain.

Word Processors
^^^^^^^^^^^^^^^

TBD

Again, it comes down to choosing the tool that stays out of your
way. For instance, our software lead and I were creating a design
document together for a new feature. We started by writing bulleted
lists in our text editors. We considered porting the text to a
``real'' tool, such as a word processor, later on. At the moment,
though, we didn't want anything to disrupt the flow of ideas. So we
continued working in text, gradually expanding each bullet into
sections, titles, and paragraphs.

As it turns out, we ended up with something so close to the ``humane
markup'' formats that it was the work of a few minutes to clean it up
and generate a nice-looking PDF to share with the rest of the team.

Keep the Code Up to Date
~~~~~~~~~~~~~~~~~~~~~~~~

TBD

Provide a Path from ``Hello world'' to Mastery
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

An engineer who stumbles across your project directory has a number of
questions, which almost certainly include the following:
* What is this thing?
* How do I get it and all the dependencies installed?
* What's the equivalent of ``Hello world'' for this system?

Closing Thoughts
----------------

TBD

Further Reading
---------------
``Writing great documentation: what to write,'' Jacob
Kaplan-Moss. November 10, 2009.
